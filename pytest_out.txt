============================= test session starts =============================
platform win32 -- Python 3.9.10, pytest-7.1.3, pluggy-1.0.0 -- D:\Dev\django_sprint4\venv\Scripts\python.exe
django: settings: blogicum.settings (from ini)
rootdir: D:\Dev\django_sprint4, configfile: pytest.ini, testpaths: tests/
plugins: Faker-12.0.1, django-4.5.2
collecting ... collected 25 items

tests/test_content.py::TestContent::test_unpublished FAILED              [  4%]
tests/test_content.py::TestContent::test_only_own_pubs_in_category PASSED [  8%]
tests/test_content.py::TestContent::test_only_own_pubs_in_profile PASSED [ 12%]
tests/test_content.py::TestContent::test_unpublished_category FAILED     [ 16%]
tests/test_content.py::TestContent::test_future_posts FAILED             [ 20%]
tests/test_content.py::TestContent::test_pagination FAILED               [ 24%]
tests/test_content.py::TestContent::test_image_visible FAILED            [ 28%]
tests/test_err_pages.py::test_custom_err_handlers FAILED                 [ 32%]
tests/test_users.py::test_custom_err_handlers FAILED                     [ 36%]
tests/test_users.py::test_profile FAILED                                 [ 40%]
tests/test_comment.py::test_comment_created_at PASSED                    [ 44%]
tests/test_comment.py::test_comment ERROR                                [ 48%]
tests/test_comment.py::test_404_on_comment_deleted_post ERROR            [ 52%]
tests/test_post.py::test_post_created_at PASSED                          [ 56%]
tests/test_post.py::test_post FAILED                                     [ 60%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`post` field] <- tests\conftest.py PASSED [ 64%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`author` field] <- tests\conftest.py PASSED [ 68%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`text` field] <- tests\conftest.py PASSED [ 72%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`created_at` field] <- tests\conftest.py PASSED [ 76%]
tests/test_emails.py::test_gitignore PASSED                              [ 80%]
tests/test_emails.py::test_email_backend_settings PASSED                 [ 84%]
tests/test_err_pages.py::test_csrf_failure_view PASSED                   [ 88%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`image` field] <- tests\conftest.py PASSED [ 92%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`pub_date` field] <- tests\conftest.py PASSED [ 96%]
tests/test_static_pages.py::test_static_pages_as_cbv PASSED              [100%]

=================================== ERRORS ====================================
_______________________ ERROR at setup of test_comment ________________________

user_client = <django.test.client.Client object at 0x000002A4E9956C70>
post_with_published_location = <Post: Recent Her Produce Authority Friend To>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests\fixtures\posts.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests\conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv\lib\site-packages\django\test\client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:204: in _get_response
    response = response.render()
venv\lib\site-packages\django\template\response.py:105: in render
    self.content = self.rendered_content
venv\lib\site-packages\django\template\response.py:83: in rendered_content
    return template.render(context, self._request)
venv\lib\site-packages\django\template\backends\django.py:61: in render
    return self.template.render(context)
venv\lib\site-packages\django\template\base.py:170: in render
    return self._render(context)
venv\lib\site-packages\django\test\utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\loader_tags.py:150: in render
    return compiled_parent._render(context)
venv\lib\site-packages\django\test\utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\loader_tags.py:62: in render
    result = block.nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\loader_tags.py:195: in render
    return template.render(context)
venv\lib\site-packages\django\template\base.py:172: in render
    return self._render(context)
venv\lib\site-packages\django\test\utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\defaulttags.py:315: in render
    return nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\library.py:192: in render
    output = self.func(*resolved_args, **resolved_kwargs)
venv\lib\site-packages\django_bootstrap5\templatetags\django_bootstrap5.py:311: in bootstrap_form
    return render_form(form, **kwargs)
venv\lib\site-packages\django_bootstrap5\forms.py:20: in render_form
    return renderer_cls(form, **kwargs).render()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django_bootstrap5.renderers.FormRenderer object at 0x000002A4E9999820>
form = '', kwargs = {}

    def __init__(self, form, **kwargs):
        if not isinstance(form, BaseForm):
>           raise TypeError('Parameter "form" should contain a valid Django Form.')
E           TypeError: Parameter "form" should contain a valid Django Form.

venv\lib\site-packages\django_bootstrap5\renderers.py:157: TypeError
_____________ ERROR at setup of test_404_on_comment_deleted_post ______________

user_client = <django.test.client.Client object at 0x000002A4EAC54EE0>
post_with_published_location = <Post: Event Represent Grow Despite Head Rather>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests\fixtures\posts.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests\conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv\lib\site-packages\django\test\client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:204: in _get_response
    response = response.render()
venv\lib\site-packages\django\template\response.py:105: in render
    self.content = self.rendered_content
venv\lib\site-packages\django\template\response.py:83: in rendered_content
    return template.render(context, self._request)
venv\lib\site-packages\django\template\backends\django.py:61: in render
    return self.template.render(context)
venv\lib\site-packages\django\template\base.py:170: in render
    return self._render(context)
venv\lib\site-packages\django\test\utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\loader_tags.py:150: in render
    return compiled_parent._render(context)
venv\lib\site-packages\django\test\utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\loader_tags.py:62: in render
    result = block.nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\loader_tags.py:195: in render
    return template.render(context)
venv\lib\site-packages\django\template\base.py:172: in render
    return self._render(context)
venv\lib\site-packages\django\test\utils.py:100: in instrumented_test_render
    return self.nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\defaulttags.py:315: in render
    return nodelist.render(context)
venv\lib\site-packages\django\template\base.py:938: in render
    bit = node.render_annotated(context)
venv\lib\site-packages\django\template\base.py:905: in render_annotated
    return self.render(context)
venv\lib\site-packages\django\template\library.py:192: in render
    output = self.func(*resolved_args, **resolved_kwargs)
venv\lib\site-packages\django_bootstrap5\templatetags\django_bootstrap5.py:311: in bootstrap_form
    return render_form(form, **kwargs)
venv\lib\site-packages\django_bootstrap5\forms.py:20: in render_form
    return renderer_cls(form, **kwargs).render()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django_bootstrap5.renderers.FormRenderer object at 0x000002A4E93DE580>
form = '', kwargs = {}

    def __init__(self, form, **kwargs):
        if not isinstance(form, BaseForm):
>           raise TypeError('Parameter "form" should contain a valid Django Form.')
E           TypeError: Parameter "form" should contain a valid Django Form.

venv\lib\site-packages\django_bootstrap5\renderers.py:157: TypeError
================================== FAILURES ===================================
________________________ TestContent.test_unpublished _________________________

self = <test_content.TestContent object at 0x000002A4E9253100>
unpublished_posts_with_published_locations = [<Post: Question Pay Today Ten Like Any>, <Post: Ok Point Guess Win House In>, <Post: Gun Success May Official Natural Improve>]

    def test_unpublished(self, unpublished_posts_with_published_locations):
        profile_response = self.profile_tester.user_client_testget()
        context_posts = profile_response.context.get(
>           self.profile_tester.items_key
        )

tests\test_content.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:152: in items_key
    key_val = _testget_context_item_by_key(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

context = [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>._get_val at ..., 'view': <blog.views.UserProfileView object at 0x000002A4E96EBDF0>, 'user': <SimpleLazyObject: <User: david63>>}, {}]]
key = 'page_obj'
err_msg = '���������, ��� � ������� ��������� �������� ������������ ���������� ���������� ��� ������ `page_obj`.'

    def _testget_context_item_by_key(context, key: str, err_msg: str) -> KeyVal:
        context_as_dict = dict(context)
        if key not in context_as_dict:
>           raise AssertionError(err_msg)
E           AssertionError: ���������, ��� � ������� ��������� �������� ������������ ���������� ���������� ��� ������ `page_obj`.

tests\conftest.py:316: AssertionError
____________________ TestContent.test_unpublished_category ____________________

self = <test_content.TestContent object at 0x000002A4E9252460>
user_client = <django.test.client.Client object at 0x000002A4E9886F70>
posts_with_unpublished_category = [<Post: Follow Skill Trouble East Impact Sign>, <Post: Avoid May Development Nice I Represent>, <Post: Evening Total Bit Agent Rate Image>]

    def test_unpublished_category(
        self, user_client, posts_with_unpublished_category
    ):
        profile_response = self.profile_tester.user_client_testget()
        context_posts = profile_response.context.get(
>           self.profile_tester.items_key
        )

tests\test_content.py:413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:152: in items_key
    key_val = _testget_context_item_by_key(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

context = [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>._get_val at ..., 'view': <blog.views.UserProfileView object at 0x000002A4E98A9DF0>, 'user': <SimpleLazyObject: <User: lgentry>>}, {}]]
key = 'page_obj'
err_msg = '���������, ��� � ������� ��������� �������� ������������ ���������� ���������� ��� ������ `page_obj`.'

    def _testget_context_item_by_key(context, key: str, err_msg: str) -> KeyVal:
        context_as_dict = dict(context)
        if key not in context_as_dict:
>           raise AssertionError(err_msg)
E           AssertionError: ���������, ��� � ������� ��������� �������� ������������ ���������� ���������� ��� ������ `page_obj`.

tests\conftest.py:316: AssertionError
________________________ TestContent.test_future_posts ________________________

self = <test_content.TestContent object at 0x000002A4E92527F0>
user_client = <django.test.client.Client object at 0x000002A4E97C1D90>
future_posts = [<Post: Call Bank New Turn Put Season>, <Post: Send Form My Could Hair Listen>, <Post: Detail Argue Miss Life Career Here>]

    def test_future_posts(self, user_client, future_posts):
        profile_response = self.profile_tester.user_client_testget()
        context_posts = profile_response.context.get(
>           self.profile_tester.items_key
        )

tests\test_content.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:152: in items_key
    key_val = _testget_context_item_by_key(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

context = [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>._get_val at ... <blog.views.UserProfileView object at 0x000002A4E9843CD0>, 'user': <SimpleLazyObject: <User: carpenterstanley>>}, {}]]
key = 'page_obj'
err_msg = '���������, ��� � ������� ��������� �������� ������������ ���������� ���������� ��� ������ `page_obj`.'

    def _testget_context_item_by_key(context, key: str, err_msg: str) -> KeyVal:
        context_as_dict = dict(context)
        if key not in context_as_dict:
>           raise AssertionError(err_msg)
E           AssertionError: ���������, ��� � ������� ��������� �������� ������������ ���������� ���������� ��� ������ `page_obj`.

tests\conftest.py:316: AssertionError
_________________________ TestContent.test_pagination _________________________

self = <test_content.TestContent object at 0x000002A4E9252DC0>
user_client = <django.test.client.Client object at 0x000002A4E98CC280>
many_posts_with_published_locations = [<Post: Still Ever Close Military Number Respond>, <Post: Bar Put Figure Unit Thought Moment>, <Post: That Common Hour... Voice Could Floor Carry Item>, <Post: Whose Friend Our Certain Buy Simple>, <Post: Live Fish South Not End Much>, ...]

    def test_pagination(
        self, user_client, many_posts_with_published_locations
    ):
        posts = many_posts_with_published_locations
    
        assert len(posts) > self.profile_tester.n_per_page
        assert len(posts) > self.main_tester.n_per_page
        assert len(posts) > self.category_tester.n_per_page
    
        for (
            tester,
            response_get_func,
            ordering_err_msg,
            pagination_err_msg,
        ) in (
            (
                self.profile_tester,
                self.profile_tester.user_client_testget,
                (
                    "���������, ��� ���������� ���������� � �������� ��������"
                    " ������� ������ ���������������� �� ������� ��"
                    " ����������, ��� ����� � ������."
                ),
                (
                    "���������, ��� �� �������� ������� ������ ��������"
                    " ���������."
                ),
            ),
            (
                self.profile_tester,
                self.profile_tester.another_client_testget,
                (
                    "���������, ��� ���������� ���������� � �������� ��������"
                    " ������� ������ ���������������� �� ������� ��"
                    " ����������, ��� ����� � ������."
                ),
                (
                    "���������, ��� �� �������� ������� ������ "
                    "��������� �������� � ������������ � �������� ."
                ),
            ),
            (
                self.main_tester,
                self.main_tester.user_client_testget,
                (
                    "���������, ��� ���������� ���������� � �������� �������"
                    " �������� ���������������� �� ������� �� ����������, ���"
                    " ����� � ������."
                ),
                "���������, ��� �� ������� �������� "
                "��������� �������� � ������������ � �������� .",
            ),
            (
                self.category_tester,
                self.category_tester.user_client_testget,
                (
                    "���������, ��� ���������� ���������� � �������� ��������"
                    " ��������� ���������������� �� ������� �� ����������, ���"
                    " ����� � ������."
                ),
                "���������, ��� �� �������� ��������� "
                "��������� �������� � ������������ � �������� .",
            ),
        ):
            response = response_get_func()
>           context_posts = response.context.get(tester.items_key)

tests\test_content.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_content.py:152: in items_key
    key_val = _testget_context_item_by_key(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

context = [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>._get_val at ...wu>>, 'view': <blog.views.UserProfileView object at 0x000002A4E98BDE50>, 'user': <SimpleLazyObject: <User: lwu>>}, {}]]
key = 'page_obj'
err_msg = '���������, ��� � ������� ��������� �������� ������������ ���������� ���������� ��� ������ `page_obj`.'

    def _testget_context_item_by_key(context, key: str, err_msg: str) -> KeyVal:
        context_as_dict = dict(context)
        if key not in context_as_dict:
>           raise AssertionError(err_msg)
E           AssertionError: ���������, ��� � ������� ��������� �������� ������������ ���������� ���������� ��� ������ `page_obj`.

tests\conftest.py:316: AssertionError
_______________________ TestContent.test_image_visible ________________________

self = <test_content.TestContent object at 0x000002A4E9250430>
user_client = <django.test.client.Client object at 0x000002A4E9910B20>
post_with_published_location = <Post: Risk Respond Single Price Class Television>

    def test_image_visible(self, user_client, post_with_published_location):
        post = post_with_published_location
        post_adapter = PostModelAdapter(post)
    
        testers: List[PostContentTester] = [
            self.profile_tester,
            self.main_tester,
            self.category_tester,
        ]
        img_n_with_post_img = {}
    
        for i, tester in enumerate(testers):
            img_soup_with_post_img = BeautifulSoup(
                tester.user_client_testget().content.decode("utf-8"),
                features="html.parser",
                parse_only=SoupStrainer("img"),
            )
            img_n_with_post_img[i] = len(img_soup_with_post_img)
    
        post_adapter.image = None
        post_adapter.save()
    
        for i, tester in enumerate(testers):
            img_soup_without_post_img = BeautifulSoup(
                tester.user_client_testget().content.decode("utf-8"),
                features="html.parser",
                parse_only=SoupStrainer("img"),
            )
            img_n_without_post_img = len(img_soup_without_post_img)
>           assert (
                img_n_with_post_img[i] - img_n_without_post_img
            ) == 1, tester.image_display_error
E           AssertionError: ���������, ��� �� �������� ������� ������ ������������ ����������� ����������.
E           assert (1 - 1) == 1

tests\test_content.py:576: AssertionError
__________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x000002A4E991CCA0>
user_client = <django.test.client.Client object at 0x000002A4E98FB370>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
>               fpath = settings.TEMPLATES_DIR / "pages" / fname

tests\test_err_pages.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <LazySettings "None">, name = 'TEMPLATES_DIR'

    def __getattr__(self, name):
        """Return the value of a setting and cache it in self.__dict__."""
        if self._wrapped is empty:
            self._setup(name)
>       val = getattr(self._wrapped, name)

venv\lib\site-packages\django\conf\__init__.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <UserSettingsHolder>, name = 'TEMPLATES_DIR'

    def __getattr__(self, name):
        if not name.isupper() or name in self._deleted:
            raise AttributeError
>       return getattr(self.default_settings, name)
E       AttributeError: 'Settings' object has no attribute 'TEMPLATES_DIR'

venv\lib\site-packages\django\conf\__init__.py:239: AttributeError

During handling of the above exception, another exception occurred:

client = <django.test.client.Client object at 0x000002A4E991CCA0>
user_client = <django.test.client.Client object at 0x000002A4E98FB370>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
                fpath = settings.TEMPLATES_DIR / "pages" / fname
            except Exception as e:
>               raise AssertionError(
                    '���������, ��� ���������� TEMPLATES_DIR � ���������� ������� '
                    '�������� ������� (str) ��� ��������, ��������������� path-like ���������� '
                    '(��������, ����������� pathlib.Path). '
                    f'��� �������� ������������ settings.TEMPLATES_DIR / "pages", �������� ������: {e}'
                )
E               AssertionError: ���������, ��� ���������� TEMPLATES_DIR � ���������� ������� �������� ������� (str) ��� ��������, ��������������� path-like ���������� (��������, ����������� pathlib.Path). ��� �������� ������������ settings.TEMPLATES_DIR / "pages", �������� ������: 'Settings' object has no attribute 'TEMPLATES_DIR'

tests\test_err_pages.py:57: AssertionError
__________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x000002A4E98D9970>

    @pytest.mark.django_db
    def test_custom_err_handlers(client):
        try:
            from blogicum import urls as blogicum_urls
        except Exception:
            raise AssertionError(
                "���������, � �������� ����� � ���������� ��� ������."
            )
        urls_src_squashed = squash_code(inspect.getsource(blogicum_urls))
        if "django.contrib.auth.urls" not in urls_src_squashed:
            raise AssertionError(
                "���������, ��� ���������� �������� ��� ������ � �������������� ��"
                " `django.contrib.auth.urls`."
            )
    
        def search_url_patterns(substring):
            resolver = get_resolver()
            results = []
    
            def search_patterns(head, patterns):
                for pattern in patterns:
                    if isinstance(pattern, URLPattern):
                        pattern_as_str = head + str(pattern.pattern)
                        if substring in pattern_as_str:
                            results.append(pattern)
                    elif isinstance(pattern, URLResolver):
                        search_patterns(
                            head + str(pattern.pattern), pattern.url_patterns
                        )
                return results
    
            search_patterns(head="", patterns=resolver.url_patterns)
    
            return results
    
        registration_url = "auth/registration/"
        auth_registration_patterns = search_url_patterns(registration_url)
>       assert auth_registration_patterns, (
            "���������, ��� � �������� ����� � ���������� ������������ �������"
            f" `{registration_url}`."
        )
E       AssertionError: ���������, ��� � �������� ����� � ���������� ������������ ������� `auth/registration/`.
E       assert []

tests\test_users.py:62: AssertionError
________________________________ test_profile _________________________________

user = <User: stuartglenda>, another_user = <User: melissarios>
user_client = <django.test.client.Client object at 0x000002A4E993D910>
another_user_client = <django.test.client.Client object at 0x000002A4E993D4F0>
unlogged_client = <django.test.client.Client object at 0x000002A4E993DFA0>

    @pytest.mark.django_db
    def test_profile(
            user, another_user, user_client, another_user_client, unlogged_client
    ):
        user_url = f"/profile/{user.username}/"
        printed_url = "/profile/<username>/"
    
        User = get_user_model()
        status_code_not_404_err_msg = (
            "���������, ��� ��� ��������� � �������� ��������������� "
            "������������ ������������ ������ 404."
        )
        try:
            response = user_client.get("/profile/this_is_unexisting_user_name/")
        except User.DoesNotExist:
            raise AssertionError(status_code_not_404_err_msg)
    
>       assert response.status_code == HTTPStatus.NOT_FOUND, (
            status_code_not_404_err_msg)
E       AssertionError: ���������, ��� ��� ��������� � �������� ��������������� ������������ ������������ ������ 404.
E       assert 200 == <HTTPStatus.NOT_FOUND: 404>
E        +  where 200 = <TemplateResponse status_code=200, "text/html; charset=utf-8">.status_code
E        +  and   <HTTPStatus.NOT_FOUND: 404> = HTTPStatus.NOT_FOUND

tests\test_users.py:111: AssertionError
__________________________________ test_post __________________________________

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x000002A4E99898E0>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv\lib\site-packages\django\core\handlers\base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x000002A4E99898E0>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv\lib\site-packages\django\core\handlers\base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, path = '/accounts/login/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
            for pattern in self.url_patterns:
                try:
                    sub_match = pattern.resolve(new_path)
                except Resolver404 as e:
                    self._extend_tried(tried, pattern, e.args[0].get('tried'))
                else:
                    if sub_match:
                        # Merge captured arguments in match with submatch
                        sub_match_dict = {**kwargs, **self.default_kwargs}
                        # Update the sub_match_dict with the kwargs from the sub_match.
                        sub_match_dict.update(sub_match.kwargs)
                        # If there are *any* named groups, ignore all non-named groups.
                        # Otherwise, pass all non-named arguments as positional arguments.
                        sub_match_args = sub_match.args
                        if not sub_match_dict:
                            sub_match_args = args + sub_match.args
                        current_route = '' if isinstance(pattern, URLPattern) else str(pattern.pattern)
                        self._extend_tried(tried, pattern, sub_match.tried)
                        return ResolverMatch(
                            sub_match.func,
                            sub_match_args,
                            sub_match_dict,
                            sub_match.url_name,
                            [self.app_name] + sub_match.app_names,
                            [self.namespace] + sub_match.namespaces,
                            self._join_route(current_route, sub_match.route),
                            tried,
                        )
                    tried.append([pattern])
>           raise Resolver404({'tried': tried, 'path': new_path})
E           django.urls.exceptions.Resolver404: {'tried': [[<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern '' [name='index']>], [<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern 'category/<slug:slug>/' [name='category_posts']>], [<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern 'posts/<int:pk>/' [name='post_detail']>], [<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern 'posts/create/' [name='create_post']>], [<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern 'posts/<int:pk>/edit/' [name='edit_post']>], [<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern 'posts/<int:post_id>/delete/' [name='delete_post']>], [<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern 'posts/<post_id>/comment/' [name='add_comment']>], [<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern 'profile/<slug:username>/' [name='profile']>], [<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>, <URLPattern 'profile/edit/' [name='edit_profile']>], [<URLResolver <URLPattern list> (admin:admin) 'admin/'>], [<URLResolver <module 'django.contrib.auth.urls' from 'D:\\Dev\\django_sprint4\\venv\\lib\\site-packages\\django\\contrib\\auth\\urls.py'> (None:None) 'auth/'>], [<URLPattern 'auth/login/' [name='login_redirect']>], [<URLResolver <module 'pages.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\pages\\urls.py'> (pages:pages) 'pages/'>]], 'path': 'accounts/login/'}

venv\lib\site-packages\django\urls\resolvers.py:589: Resolver404

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>, status_code = 404
exception = Resolver404({'tried': [[<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blo....urls' from 'D:\\Dev\\django_sprint4\\blogicum\\pages\\urls.py'> (pages:pages) 'pages/'>]], 'path': 'accounts/login/'})

    def get_exception_response(request, resolver, status_code, exception):
        try:
            callback = resolver.resolve_error_handler(status_code)
>           response = callback(request, exception=exception)

venv\lib\site-packages\django\core\handlers\exception.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exception = Resolver404({'tried': [[<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blo....urls' from 'D:\\Dev\\django_sprint4\\blogicum\\pages\\urls.py'> (pages:pages) 'pages/'>]], 'path': 'accounts/login/'})

    def page_not_found(request, exception):
>       return render(request, 'pages/404.html', status=404)

blogicum\core\views.py:5: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/404.html', context = None, content_type = None
status = 404, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/404.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4EAB52400>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAE41DF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAE41DF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <debug_toolbar.middleware.DebugToolbarMiddleware object at 0x000002A4E940E940>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def __call__(self, request):
        # Decide whether the toolbar is active for this request.
        show_toolbar = get_show_toolbar()
        if not show_toolbar(request) or DebugToolbar.is_toolbar_request(request):
>           return self.get_response(request)

venv\lib\site-packages\debug_toolbar\middleware.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = Resolver404({'tried': [[<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blo....urls' from 'D:\\Dev\\django_sprint4\\blogicum\\pages\\urls.py'> (pages:pages) 'pages/'>]], 'path': 'accounts/login/'})

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
>               response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)

venv\lib\site-packages\django\core\handlers\exception.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>, status_code = 404
exception = Resolver404({'tried': [[<URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blo....urls' from 'D:\\Dev\\django_sprint4\\blogicum\\pages\\urls.py'> (pages:pages) 'pages/'>]], 'path': 'accounts/login/'})

    def get_exception_response(request, resolver, status_code, exception):
        try:
            callback = resolver.resolve_error_handler(status_code)
            response = callback(request, exception=exception)
        except Exception:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, resolver, sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4E96F0FC0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4EAB525B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x000002A4E940EDC0>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4E96AC680>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4EAB53460>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x000002A4EAE41700>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4E96E7240>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4E990D5E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x000002A4EAE412E0>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4E9975D40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4E990D580>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x000002A4EAE41670>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4EA9D1980>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4EAB77A60>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.common.CommonMiddleware object at 0x000002A4EAE41580>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4E97F0740>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4EAB77700>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x000002A4EAE414C0>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4E97F8B40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4EAB6C9D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.security.SecurityMiddleware object at 0x000002A4EAE415B0>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4E9970B40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4EAB6C250>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

During handling of the above exception, another exception occurred:

self = <form.post.create_form_tester.CreatePostFormTester object at 0x000002A4E93CD280>
form = <YourPostForm bound=True, valid=True, fields=(title;text;pub_date;location;category;image)>
qs = <QuerySet [<Post: Wear Take Too Street Day Several>]>
submitter = <form.base_form_tester.AnonymousSubmitTester object at 0x000002A4E93F91D0>
assert_created = False

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        if not form.is_valid():
            raise FormValidationException(form.errors)
        elif form.errors:
            raise FormValidationException(form.errors)
    
        items_before = set(qs.all())
    
        restored_data = restore_cleaned_data(form.cleaned_data)
        try:
>           response = submitter.test_submit(
                url=self._action, data=restored_data
            )

tests\form\base_form_tester.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <form.base_form_tester.AnonymousSubmitTester object at 0x000002A4E93F91D0>
url = '/posts/create/'
data = {'category': 5, 'image': <SimpleUploadedFile: test_image.jpg (image/jpeg)>, 'location': 4, 'pub_date': datetime.datetime(2024, 3, 15, 13, 41, 30, 112735, tzinfo=<UTC>), ...}

    def test_submit(self, url: str, data: dict) -> HttpResponse:
        assert isinstance(self.client, django.test.Client)
>       response = self.client.post(url, data=data, follow=True)

tests\form\base_form_tester.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x000002A4E9989280>
path = '/posts/create/'
data = {'category': 5, 'image': <SimpleUploadedFile: test_image.jpg (image/jpeg)>, 'location': 4, 'pub_date': datetime.datetime(2024, 3, 15, 13, 41, 30, 112735, tzinfo=<UTC>), ...}
content_type = 'multipart/form-data; boundary=BoUnDaRyStRiNg', follow = True
secure = False, extra = {}
response = <HttpResponseRedirect status_code=302, "text/html; charset=utf-8", url="/accounts/login/?next=/posts/create/">

    def post(self, path, data=None, content_type=MULTIPART_CONTENT,
             follow=False, secure=False, **extra):
        """Request a response from the server using POST."""
        self.extra = extra
        response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
        if follow:
>           response = self._handle_redirects(response, data=data, content_type=content_type, **extra)

venv\lib\site-packages\django\test\client.py:753: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x000002A4E9989280>
response = <HttpResponseRedirect status_code=302, "text/html; charset=utf-8", url="/accounts/login/?next=/posts/create/">
data = <QueryDict: {'next': ['/posts/create/']}>, content_type = None
extra = {}
redirect_status_codes = (<HTTPStatus.MOVED_PERMANENTLY: 301>, <HTTPStatus.FOUND: 302>, <HTTPStatus.SEE_OTHER: 303>, <HTTPStatus.TEMPORARY_REDIRECT: 307>, <HTTPStatus.PERMANENT_REDIRECT: 308>)
response_url = '/accounts/login/?next=/posts/create/'
redirect_chain = [('/accounts/login/?next=/posts/create/', 302)]
url = SplitResult(scheme='', netloc='', path='/accounts/login/', query='next=/posts/create/', fragment='')
path = '/accounts/login/'
request_method = <bound method Client.get of <django.test.client.Client object at 0x000002A4E9989280>>

    def _handle_redirects(self, response, data='', content_type='', **extra):
        """
        Follow any redirects by requesting responses from the server using GET.
        """
        response.redirect_chain = []
        redirect_status_codes = (
            HTTPStatus.MOVED_PERMANENTLY,
            HTTPStatus.FOUND,
            HTTPStatus.SEE_OTHER,
            HTTPStatus.TEMPORARY_REDIRECT,
            HTTPStatus.PERMANENT_REDIRECT,
        )
        while response.status_code in redirect_status_codes:
            response_url = response.url
            redirect_chain = response.redirect_chain
            redirect_chain.append((response_url, response.status_code))
    
            url = urlsplit(response_url)
            if url.scheme:
                extra['wsgi.url_scheme'] = url.scheme
            if url.hostname:
                extra['SERVER_NAME'] = url.hostname
            if url.port:
                extra['SERVER_PORT'] = str(url.port)
    
            # Prepend the request path to handle relative path redirects
            path = url.path
            if not path.startswith('/'):
                path = urljoin(response.request['PATH_INFO'], path)
    
            if response.status_code in (HTTPStatus.TEMPORARY_REDIRECT, HTTPStatus.PERMANENT_REDIRECT):
                # Preserve request method and query string (if needed)
                # post-redirect for 307/308 responses.
                request_method = response.request['REQUEST_METHOD'].lower()
                if request_method not in ('get', 'head'):
                    extra['QUERY_STRING'] = url.query
                request_method = getattr(self, request_method)
            else:
                request_method = self.get
                data = QueryDict(url.query)
                content_type = None
    
>           response = request_method(path, data=data, content_type=content_type, follow=False, **extra)

venv\lib\site-packages\django\test\client.py:850: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x000002A4E9989280>
path = '/accounts/login/', data = <QueryDict: {'next': ['/posts/create/']}>
follow = False, secure = False, extra = {'content_type': None}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x000002A4E9989280>
path = '/accounts/login/', data = <QueryDict: {'next': ['/posts/create/']}>
secure = False, extra = {'content_type': None}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x000002A4E9989280>, method = 'GET'
path = '/accounts/login/', data = b'', content_type = None, secure = False
extra = {'QUERY_STRING': 'next=%2Fposts%2Fcreate%2F'}
parsed = ParseResult(scheme='', netloc='', path='/accounts/login/', params='', query='', fragment='')
r = {'PATH_INFO': '/accounts/login/', 'QUERY_STRING': 'next=%2Fposts%2Fcreate%2F', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x000002A4E9989280>
request = {'PATH_INFO': '/accounts/login/', 'QUERY_STRING': 'next=%2Fposts%2Fcreate%2F', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': '', 'PATH_INFO': '/accounts/login/', 'QUERY_STRING': 'next=%2Fposts%2Fcreate%2F', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....mplate.base.Template object at 0x000002A4E996F040>, <django.template.base.Template object at 0x000002A4EAC41C10>, ...]}
on_template_render = functools.partial(<function store_rendered_templates at 0x000002A4E8AB58B0>, {'templates': [<django.template.base.Temp...4EAE41250>, 'DEFAULT_MESSAGE_LEVELS': {'DEBUG': 10, 'INFO': 20, 'SUCCESS': 25, 'WARNING': 30, 'ERROR': 40}}, {}, {}]]})
signal_uid = 'template-render-2907309770816'
exception_uid = 'request-exception-2907309770816'

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
>           response = self.handler(environ)

venv\lib\site-packages\django\test\client.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x000002A4E99898E0>
environ = {'HTTP_COOKIE': '', 'PATH_INFO': '/accounts/login/', 'QUERY_STRING': 'next=%2Fposts%2Fcreate%2F', 'REMOTE_ADDR': '127.0.0.1', ...}

    def __call__(self, environ):
        # Set up middleware if needed. We couldn't do this earlier, because
        # settings weren't available.
        if self._middleware_chain is None:
            self.load_middleware()
    
        request_started.disconnect(close_old_connections)
        request_started.send(sender=self.__class__, environ=environ)
        request_started.connect(close_old_connections)
        request = WSGIRequest(environ)
        # sneaky little hack so that we can easily get round
        # CsrfViewMiddleware.  This makes life easier, and is probably
        # required for backwards compatibility with external tests against
        # admin views.
        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks
    
        # Request goes through middleware.
>       response = self.get_response(request)

venv\lib\site-packages\django\test\client.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x000002A4E99898E0>
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def get_response(self, request):
        """Return an HttpResponse object for the given HttpRequest."""
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF)
>       response = self._middleware_chain(request)

venv\lib\site-packages\django\core\handlers\base.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
exc = NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'django.urls.exceptions.NoReverseMatch'>, NoReverseMatch("Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name."), <traceback object at 0x000002A4E9991900>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
        callback = resolver.resolve_error_handler(500)
>       return callback(request)

venv\lib\site-packages\django\core\handlers\exception.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def server_error(request):
>       return render(request, 'pages/500.html', status=500)

blogicum\core\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
template_name = 'pages/500.html', context = None, content_type = None
status = 500, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'pages/500.html', context = None
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x000002A4EAB6CB80>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <WSGIRequest: GET '/accounts/login/?next=%2Fposts%2Fcreate%2F'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAB533A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4E996F040>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EACD4130>, <TextNode: '\n'>, <django.template.defaulttags.L... </main>'>, <django.template.loader_tags.IncludeNode object at 0x000002A4EAC41EE0>, <TextNode: '\n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x000002A4EACD4EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x000002A4EAC41C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x000002A4EAE65C40>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...t 0x000002A4EAE656D0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '\n    </div>\n  </nav>\n</he'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n        <ul class="nav  '>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...ect at 0x000002A4EACCF8E0>, <TextNode: '">\n              �������\n'>, <IfNode>, <TextNode: '\n        </ul>\n      '>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <IfNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        for condition, nodelist in self.conditions_nodelists:
    
            if condition is not None:           # if / elif clause
                try:
                    match = condition.eval(context)
                except VariableDoesNotExist:
                    match = None
            else:                               # else clause
                match = True
    
            if match:
>               return nodelist.render(context)

venv\lib\site-packages\django\template\defaulttags.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '\n            <div class="'>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFD00>, <TextNo...>\n    '>, <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>, <TextNode: '">�����������</a></button'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x000002A4EACCFE50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'blog:registration', urlconf = 'blogicum.urls', args = []
kwargs = {}, current_app = None

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
                        raise NoReverseMatch("%s is not a registered namespace" % key)
            if ns_pattern:
                resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))
    
>       return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)

venv\lib\site-packages\django\urls\base.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver <module 'blog.urls' from 'D:\\Dev\\django_sprint4\\blogicum\\blog\\urls.py'> (blog:blog) ''>
lookup_view = 'registration', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    if any(kwargs.get(k, v) != v for k, v in defaults.items()):
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%') + result
                if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None)
        n = getattr(lookup_view, '__name__', None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = (
                "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" %
                (lookup_view_s, arg_msg, len(patterns), patterns)
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {'view': lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

venv\lib\site-packages\django\urls\resolvers.py:698: NoReverseMatch

The above exception was the direct cause of the following exception:

self = <form.post.create_form_tester.CreatePostFormTester object at 0x000002A4E93CD280>
form = <YourPostForm bound=True, valid=True, fields=(title;text;pub_date;location;category;image)>
qs = <QuerySet [<Post: Wear Take Too Street Day Several>]>
submitter = <form.base_form_tester.AnonymousSubmitTester object at 0x000002A4E93F91D0>
assert_created = False

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        try:
>           return super().try_create_item(form, qs, submitter, assert_created)

tests\form\post\create_form_tester.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <form.post.create_form_tester.CreatePostFormTester object at 0x000002A4E93CD280>
form = <YourPostForm bound=True, valid=True, fields=(title;text;pub_date;location;category;image)>
qs = <QuerySet [<Post: Wear Take Too Street Day Several>]>
submitter = <form.base_form_tester.AnonymousSubmitTester object at 0x000002A4E93F91D0>
assert_created = False

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        if not form.is_valid():
            raise FormValidationException(form.errors)
        elif form.errors:
            raise FormValidationException(form.errors)
    
        items_before = set(qs.all())
    
        restored_data = restore_cleaned_data(form.cleaned_data)
        try:
            response = submitter.test_submit(
                url=self._action, data=restored_data
            )
        except Exception as e:
>           raise FormValidationException(e) from e
E           form.base_form_tester.FormValidationException: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

tests\form\base_form_tester.py:207: FormValidationException

The above exception was the direct cause of the following exception:

published_category = <Category: Concern Should Program All Father Although>
published_location = <Location: Dr. Christian Gomez>
user_client = <django.test.client.Client object at 0x000002A4E9989850>
another_user_client = <django.test.client.Client object at 0x000002A4E99890D0>
unlogged_client = <django.test.client.Client object at 0x000002A4E9989280>
comment_to_a_post = <Comment: �� alisonbrooks ��� Wear Take Too Street Day Several>
create_post_context_form_item = KeyVal(key='form', val=<YourPostForm bound=False, valid=False, fields=(title;text;pub_date;location;category;image)>)
PostModel = <class 'blog.models.Post'>
CommentModelAdapter = <class 'adapters.comment.CommentModelAdapter.<locals>._CommentModelAdapter'>
main_content_tester = <test_content.MainPostContentTester object at 0x000002A4EACD4610>

    @pytest.mark.django_db(transaction=True)
    def test_post(
            published_category: Model,
            published_location: Model,
            user_client: django.test.Client,
            another_user_client: django.test.Client,
            unlogged_client: django.test.Client,
            comment_to_a_post: Model,
            create_post_context_form_item: Tuple[str, BaseForm],
            PostModel: Type[Model],
            CommentModelAdapter: CommentModelAdapterT,
            main_content_tester: MainPostContentTester
    ):
        _, ctx_form = create_post_context_form_item
    
        create_a_post_get_response = get_create_a_post_get_response_safely(
            user_client
        )
    
>       response_on_created, created_items = _test_create_items(
            PostModel,
            PostModelAdapter,
            another_user_client,
            create_a_post_get_response,
            ctx_form,
            published_category,
            published_location,
            unlogged_client,
            user_client,
        )

tests\test_post.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_post.py:298: in _test_create_items
    creation_tester.test_unlogged_cannot_create(
tests\form\post\create_form_tester.py:88: in test_unlogged_cannot_create
    super().test_unlogged_cannot_create(form, qs)
tests\form\base_form_tester.py:249: in test_unlogged_cannot_create
    self.test_create_item(
tests\form\base_form_tester.py:264: in test_create_item
    response, created = self.try_create_item(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <form.post.create_form_tester.CreatePostFormTester object at 0x000002A4E93CD280>
form = <YourPostForm bound=True, valid=True, fields=(title;text;pub_date;location;category;image)>
qs = <QuerySet [<Post: Wear Take Too Street Day Several>]>
submitter = <form.base_form_tester.AnonymousSubmitTester object at 0x000002A4E93F91D0>
assert_created = False

    def try_create_item(
        self,
        form: BaseForm,
        qs: QuerySet,
        submitter: SubmitTester,
        assert_created: bool = True,
    ) -> Tuple[HttpResponse, Model]:
        try:
            return super().try_create_item(form, qs, submitter, assert_created)
        except FormValidationException as e:
>           raise AssertionError(
                "��� �������� ����� ��������� ������:\n"
                f"{type(e).__name__}: {e}"
            ) from e
E           AssertionError: ��� �������� ����� ��������� ������:
E           FormValidationException: Reverse for 'registration' not found. 'registration' is not a valid view function or pattern name.

tests\form\post\create_form_tester.py:79: AssertionError
=========================== short test summary info ===========================
ERROR tests/test_comment.py::test_comment - TypeError: Parameter "form" shoul...
ERROR tests/test_comment.py::test_404_on_comment_deleted_post - TypeError: Pa...
============= 9 failed, 14 passed, 2 warnings, 2 errors in 3.80s ==============
